@page "/"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Components.Forms
@using System.Text.Json
@using PoImageGc.Web.Models
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@inject ILogger<Home> Logger
@inject NavigationManager NavigationManager

<PageTitle>PoImageGc — AI Image Studio</PageTitle>

<div class="container py-4">
    @if (!isProcessing && !isComplete)
    {
        <div class="hero-section text-center mb-5">
            <div class="hero-icon mb-3">
                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="none" viewBox="0 0 24 24" stroke="url(#grad1)" stroke-width="1.5">
                    <defs>
                        <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#0527671" />
                            <stop offset="100%" style="stop-color:#3a0647" />
                        </linearGradient>
                    </defs>
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456z" />
                </svg>
            </div>
            <h1 class="hero-title">AI Image Studio</h1>
            <p class="hero-subtitle">Reimagine your photos — regenerate with AI artistry or generate memes instantly.</p>
        </div>

        <div class="row justify-content-center">
            <div class="col-lg-7 col-md-9">
                <ImageUploadPanel
                    SelectedMode="@selectedMode"
                    DescriptionLength="@descriptionLength"
                    ImagePreviewUrl="@imagePreviewUrl"
                    ErrorMessage="@errorMessage"
                    CanProcess="@canProcessImage"
                    OnFileChange="LoadFile"
                    OnProcessClicked="ProcessImage"
                    OnModeChanged="@(m => selectedMode = m)"
                    OnDescriptionLengthChanged="@(l => descriptionLength = l)" />
            </div>
        </div>
    }

    @if (isProcessing)
    {
        <div class="row justify-content-center mt-4">
            <div class="col-lg-7 col-md-9">
                <ProcessingProgressBar Percentage="@progressPercentage" Message="@progressMessage" />
            </div>
        </div>
    }

    @if (isComplete)
    {
        <ResultsPanel
            ImagePreviewUrl="@imagePreviewUrl"
            RegeneratedImageUrl="@regeneratedImageUrl"
            AnalysisResult="@analysisResult"
            ImageDescription="@imageDescription"
            SelectedMode="@selectedMode"
            SideBySideGenerating="@_sideBySideGenerating"
            OnDownloadOriginal="DownloadOriginal"
            OnDownloadMeme="DownloadMeme"
            OnDownloadRegenerated="DownloadRegenerated"
            OnDownloadSideBySide="DownloadSideBySide"
            OnStartOver="StartOver" />
    }

    @if (!isProcessing && !isComplete && !string.IsNullOrEmpty(errorMessage))
    {
        <div class="row justify-content-center mt-2">
            <div class="col-lg-7 col-md-9">
                <div class="alert alert-danger d-flex align-items-center gap-2">
                    <i class="bi bi-exclamation-triangle-fill flex-shrink-0"></i>
                    <span>@errorMessage</span>
                </div>
            </div>
        </div>
    }
</div>

@code {
    private IBrowserFile? selectedFile;
    private string? imagePreviewUrl;
    private string? regeneratedImageUrl;
    private string? imageDescription;
    private string? errorMessage;
    private bool isProcessing;
    private bool isComplete;
    private bool _sideBySideGenerating;
    private bool canProcessImage => selectedFile != null && string.IsNullOrEmpty(errorMessage);
    private int progressPercentage;
    private string progressMessage = string.Empty;
    private int descriptionLength = 350;
    private const int MaxFileSize = 20 * 1024 * 1024; // 20 MB
    private ImageAnalysisResult? analysisResult;
    private ProcessingMode selectedMode = ProcessingMode.ImageRegeneration;

    private async Task LoadFile(InputFileChangeEventArgs e)
    {
        try
        {
            selectedFile = e.File;
            errorMessage = null;
            imagePreviewUrl = null;

            var fileType = Path.GetExtension(selectedFile.Name).ToLower();
            if (fileType != ".jpg" && fileType != ".jpeg" && fileType != ".png")
            {
                errorMessage = "Only JPG and PNG files are supported.";
                selectedFile = null;
                return;
            }

            if (selectedFile.Size > MaxFileSize)
            {
                errorMessage = $"File size exceeds the maximum allowed (20 MB). Current: {Math.Round(selectedFile.Size / 1024.0 / 1024.0, 2)} MB";
                selectedFile = null;
                return;
            }

            using var ms = new MemoryStream();
            await using var stream = selectedFile.OpenReadStream(MaxFileSize);
            await stream.CopyToAsync(ms);
            var buffer = ms.ToArray();

            var base64Image = Convert.ToBase64String(buffer);
            var contentType = selectedFile.ContentType;
            if (string.IsNullOrEmpty(contentType))
            {
                contentType = fileType switch
                {
                    ".jpg" or ".jpeg" => "image/jpeg",
                    ".png" => "image/png",
                    _ => "image/jpeg"
                };
            }

            imagePreviewUrl = $"data:{contentType};base64,{base64Image}";
            StateHasChanged();
            Logger.LogInformation("Image loaded: {Name}, {KB:F1} KB", selectedFile.Name, selectedFile.Size / 1024.0);
        }
        catch (Exception ex)
        {
            errorMessage = $"Error loading image: {ex.Message}";
            Logger.LogError(ex, "Error loading image");
        }
    }

    private async Task ProcessImage()
    {
        if (selectedFile == null || imagePreviewUrl == null) return;

        try
        {
            isProcessing = true;
            errorMessage = null;
            progressPercentage = 10;
            progressMessage = "Preparing image for analysis...";
            StateHasChanged();

            var base64Data = imagePreviewUrl;
            var base64Index = imagePreviewUrl.IndexOf(";base64,", StringComparison.OrdinalIgnoreCase);
            if (base64Index >= 0)
                base64Data = imagePreviewUrl[(base64Index + 8)..];

            var request = new ImageAnalysisRequest
            {
                ImageData = base64Data,
                ContentType = selectedFile.ContentType,
                FileName = selectedFile.Name,
                DescriptionLength = descriptionLength,
                Mode = selectedMode
            };

            progressPercentage = 30;
            progressMessage = "Analyzing image with Azure Computer Vision...";
            StateHasChanged();

            try
            {
                using var cts = new CancellationTokenSource(TimeSpan.FromMinutes(3));
                var httpResponse = await Http.PostAsJsonAsync("api/images/analyze", request, cts.Token);
                httpResponse.EnsureSuccessStatusCode();
                analysisResult = await httpResponse.Content.ReadFromJsonAsync<ImageAnalysisResult>();

                if (analysisResult == null)
                    throw new InvalidOperationException("No response received from API.");

                imageDescription = analysisResult.Description;
                regeneratedImageUrl = selectedMode == ProcessingMode.ImageRegeneration && !string.IsNullOrEmpty(analysisResult.RegeneratedImageData)
                    ? $"data:{analysisResult.RegeneratedImageContentType};base64,{analysisResult.RegeneratedImageData}"
                    : null;
            }
            catch (OperationCanceledException ex)
            {
                Logger.LogError(ex, "Request timed out after 3 minutes");
                errorMessage = "Image generation timed out. Please try again with a different image.";
            }
            catch (HttpRequestException ex) when ((int?)ex.StatusCode >= 500)
            {
                Logger.LogError(ex, "Server error");
                errorMessage = $"A server error occurred: {ex.Message}";
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error calling API");
                errorMessage = $"Error processing image: {ex.Message}";
            }
            finally
            {
                progressPercentage = 100;
                progressMessage = string.IsNullOrEmpty(errorMessage) ? "Processing complete!" : "Processing failed.";
                isProcessing = false;
                // Only transition to results view when processing succeeded;
                // on failure the user stays on the upload panel so they can retry.
                isComplete = string.IsNullOrEmpty(errorMessage);
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error processing image: {ex.Message}";
            isProcessing = false;
            Logger.LogError(ex, "Error processing image");
        }
    }

    private async Task DownloadOriginal()
    {
        if (imagePreviewUrl == null) return;
        var ok = await JSRuntime.InvokeAsync<bool>("downloadImage", imagePreviewUrl, selectedFile?.Name ?? "original.jpg");
        if (!ok) errorMessage = "There was a problem downloading the image.";
        else Logger.LogInformation("Original image download initiated");
    }

    private async Task DownloadMeme()
    {
        if (analysisResult?.MemeImageData == null) return;
        var url = $"data:image/png;base64,{analysisResult.MemeImageData}";
        var ok = await JSRuntime.InvokeAsync<bool>("downloadImage", url, "meme-" + (selectedFile?.Name ?? "image.png"));
        if (!ok) errorMessage = "There was a problem downloading the meme image.";
        else Logger.LogInformation("Meme image download initiated");
    }

    private async Task DownloadRegenerated()
    {
        if (regeneratedImageUrl == null) return;
        var ok = await JSRuntime.InvokeAsync<bool>("downloadImage", regeneratedImageUrl, "regenerated-" + (selectedFile?.Name ?? "image.png"));
        if (!ok) errorMessage = "There was a problem downloading the regenerated image.";
        else Logger.LogInformation("Regenerated image download initiated");
    }

    private async Task DownloadSideBySide()
    {
        if (imagePreviewUrl == null || regeneratedImageUrl == null) return;
        _sideBySideGenerating = true;
        StateHasChanged();
        try
        {
            await JSRuntime.InvokeVoidAsync("createSideBySideComparison",
                imagePreviewUrl, regeneratedImageUrl,
                "comparison-" + (selectedFile?.Name ?? "image.png"));
            Logger.LogInformation("Side-by-side comparison download initiated");
        }
        catch (Exception ex)
        {
            errorMessage = $"Error creating comparison image: {ex.Message}";
            Logger.LogError(ex, "Error creating comparison image");
        }
        finally
        {
            _sideBySideGenerating = false;
            StateHasChanged();
        }
    }

    private void StartOver()
    {
        selectedFile = null;
        imagePreviewUrl = null;
        regeneratedImageUrl = null;
        imageDescription = null;
        errorMessage = null;
        isProcessing = false;
        isComplete = false;
        _sideBySideGenerating = false;
        progressPercentage = 0;
        progressMessage = string.Empty;
        analysisResult = null;
        selectedMode = ProcessingMode.ImageRegeneration;
        Logger.LogInformation("Process reset");
    }
}
